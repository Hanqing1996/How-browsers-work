


#### 静态语言和动态语言

```c++
int main()
{
   int a = 1;
   char* b = "极客时间";
   bool c = true;
   return 0;
}
```

上述代码声明变量的特点是：在声明变量之前需要先定义变量类型。我们把这种在使用之前就需要确认其变量数据类型的称为静态语言。
相反地，我们把在运行过程中需要检查数据类型的语言称为动态语言。比如我们所讲的 JavaScript 就是动态语言，因为在声明变量之前并不需要确认其数据类型。


#### 弱类型语言和强类型语言

前面代码中，我们把 int 型的变量 a 赋值给了 bool 型的变量 c，这段代码也是可以编译执行的，因为在赋值过程中，C 编译器会把 int 型的变量悄悄转换为 bool 型的变量，我们通常把这种偷偷转换的操作称为隐式类型转换。而支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言。在这点上，C 和 JavaScript 都是弱类型语言。

![Alt](https://i.loli.net/2020/10/12/Vl4iS13LtKg7n9P.jpg)

####  JavaScript 是一种弱类型的、动态的语言。那这些特点意味着什么呢？

弱类型，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。
动态，意味着你可以使用同一个变量保存不同类型的数据。

---

#### 变量存于栈->变量存于执行上下文，执行上下文存于调用栈

![Alt](https://i.loli.net/2020/10/12/2LlayimFkOjQcze.jpg)
从图中可以看出来，当执行到第 3 行时，变量 a 和变量 b 的值都被保存在执行上下文中，而执行上下文又被压入到栈中，所以你也可以认为变量 a 和变量 b 的值都是存放在栈中的。

---

#### 闭包内存模型

```js
function foo() {
    var myName = "极客时间"
    let test1 = 1
    const test2 = 2
    var innerBar = { 
        setName:function(newName){
            myName = newName
        },
        getName:function(){
            console.log(test1)
            return myName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("极客邦")
bar.getName()
console.log(bar.getName())
```


当执行这段代码的时候，你应该有过这样的分析：由于变量 myName、test1、test2 都是原始类型数据，所以在执行 foo 函数的时候，它们会被压入到调用栈中；当 foo 函数执行结束之后，调用栈中 foo 函数的执行上下文会被销毁，其内部变量 myName、test1、test2 也应该一同被销毁。

但是实际上，**当 foo 函数的执行上下文销毁时，由于 foo 函数产生了闭包，所以变量 myName 和 test1 并没有被销毁，而是保存在内存中，**那么应该如何解释这个现象呢？


#### 闭包内存模型

要解释这个现象，我们就得站在内存模型的角度来分析这段代码的执行流程。

当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。

在编译过程中，**遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描**，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。

接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。
由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中。

通过上面的分析，我们可以画出执行到 foo 函数中“return innerBar”语句时的调用栈状态，如下图所示：

![Alt](https://i.loli.net/2020/10/12/TrlWkSV2AnjdKmb.jpg)

从上图你可以清晰地看出，当执行到 foo 函数时，闭包就产生了；当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用“clourse(foo)”对象，所以即使 foo 函数退出了，“clourse(foo)”依然被其内部的 getName 和 setName 方法引用。所以在下次调用bar.setName或者bar.getName时，创建的执行上下文中就包含了“clourse(foo)”。

总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。

---

#### setname方法是通过什么引用闭包的

getName的执行上下文环境中的变量环境中存着指向堆内存closeure(foo)的变量

setname的作用域[[Scopes]]中有Closure(foo)

闭包是外部函数的变量集合，内部函数setname保留着对外部函数的变量引用，这个变量引用指向了堆内存中的closeure(foo)

---

#### 我对闭包模型的理解

其实就是一个函数fa在 pre-parse（或者parse？倾向于parse，因为效率更高）阶段时，会检测它内部定义的函数(也就是pre-parse这些函数，是一个确定作用域的过程）引用了哪些在fa内部声明的变量。然后将其存入closure(fa)中。

在fa的上下文被销毁后，closure(fa)会依然存在，以保证函数依然能访问到对应变量。


> 引擎在编译时做词法分析时，如果发现内部函数引用了外部函数的变量，就认为它是闭包，会在堆中创建一个closure对象，并把其中访问的所有变量都放进这个对象里，**然后把这个closure对象的地址返回给上级上下文**。

---

字符串，symbol，bigint虽然是原始类型，但是实际还是存放在堆空间的。
比如字符串的大小可能很大，考虑性能还是存放在堆空间。
具体浏览器控制台 => memory => 打印快照，在heal里搜索string，可以发现字符串在堆空间
这个问题，网上基本都是错的，也很少有文档数据介绍，最新的绿皮书有提到

---

作者回复: 看来我有必要重新解释一下静态类型和动态类型，强类型和弱类型的区别了！

要理解一门语言是静态类型还是动态类型，最本质的判断方法是看在什么时间段对类型就行检测，静态类型的语言会在编译阶段就行检测，动态类型的语言会在运行时做类型检测！

比如C/C++是静态语言，会在编译阶段对类型就行检测，如果检测到不合法的语言，编译阶段就会报错！

而JavaScript就是动态语言，编译阶段不会做太多类型检测，而是等到运行时再检测变量的具体类型，这是动态语言性能低于静态语言的一个关键的地方。V8对这种动态性做了大量的优化！

要理解一门语言是弱类型还是强类型，看变量在运行时，是否能够改变类型，比如C/c++/javaScript,都可以在运行时将一种类型的变量，改成另外一种类型的，所以他们是弱类型，而JAVA就不能运行过程中修改变量类型，所以是静态语言！

