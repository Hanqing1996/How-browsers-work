![Alt](https://i.loli.net/2020/11/09/pqiJWA4y1cowxub.jpg)


ast-字节码-机器码

#### Ignition

Ignition 既生成字节码，又执行字节码

* 执行上下文生命周期的创建阶段
  Ignition 负责将 AST 转换为字节码
* 执行代码
  Ignition 解释器直接解释字节码执行


#### AST

AST 是为了让解释器/编译器理解而提出的。

高级语言是开发者可以理解的语言，但是让编译器或者解释器来理解就非常困难了。对于编译器或者解释器来说，它们可以理解的就是 AST 了。所以无论你使用的是解释型语言还是编译型语言，在编译过程中，它们都会生成一个 AST。这和渲染引擎将 HTML 格式文件转换为计算机可以理解的 DOM 树的情况类似。


#### Babel

Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。


#### v8字节码的由来

AST直接转成机器码是很高效的做法（也是v8一开始的方案）。只是由于机器码占内存过大，对于后来v8团队改用字节码作为中间代码。

本质上是用时间换空间。


其实一开始 V8 并没有字节码，而是直接将 AST 转换为机器码，由于执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着 Chrome 在手机上的广泛普及，特别是运行在 512M 内存的手机上，内存占用问题也暴露出来了，因为 V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器，最终花了将进四年的时间，实现了现在的这套架构。

那什么是字节码呢？为什么引入字节码就能解决内存占用问题呢？
字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。

![Alt](https://i.loli.net/2020/11/09/abX6lL3U5ZxArMH.jpg)

从图中可以看出，机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。


#### 解释器Ignition 和编译器 TurboFan 的交互

Ignition 生成和执行字节码，在执行字节码过程中，如果发现某段代码被重复执行，就将其标记为热点代码，由 TurboFan 生成高效机器码。之后执行到该段代码时，直接执行对应机器码。

通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。到了这里，相信你已经发现了，解释器 Ignition 除了负责生成字节码之外，它还有另外一个作用，就是解释执行字节码。在 Ignition 执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。

V8 的解释器和编译器的取名也很有意思。解释器 Ignition 是点火器的意思，编译器 TurboFan 是涡轮增压的意思，寓意着代码启动时通过点火器慢慢发动，一旦启动，涡轮增压介入，其执行效率随着执行时间越来越高效率，因为热点代码都被编译器 TurboFan 转换了机器码，直接执行机器码就省去了字节码“翻译”为机器码的过程。


#### 即时编译（JIT）

其实字节码配合解释器和编译器是最近一段时间很火的技术，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为即时编译（JIT）。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。

对于 JavaScript 工作引擎，除了 V8 使用了“字节码 +JIT”技术之外，苹果的 SquirrelFish Extreme 和 Mozilla 的 SpiderMonkey 也都使用了该技术。

![Alt](https://i.loli.net/2020/11/09/kB1dUWtRjx2nPYg.jpg)

#### V8解析后的字节码或热节点的机器码是存在哪的，是以缓存的形式存储的么？

是以哈希表形式存在堆内存中的


#### 二进制和机器码

二进制文件是最后输出的文件，计算机可以执行的是二进制文件。机器码是整个流程最后的步骤，目的是调用系统的硬件如大量使用的寄存器进行计算，然后生成二进制


#### 为什么V8执行越久, 效率越高

V8刚开始执行代码的时候, 都是通过ignition解释器来逐行解析字节码的, 这样性能会比较慢. 当执行一段时间过后, ignition可以捕获到经常被执行的到的字节码. 这些字节码就会被作为热代码交给turbofan编译成为机器码. 后续可以直接使用机器码, 而机器码的执行效率优于字节码. 当V8执行越久, 使用量高的字节码都被编译为机器码. 故V8执行越久, 效率越高。

想了解更多关于 JIT 的原理，可以看这个 https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/


#### 既然字节码最后还是要转化为机器码，为什么说有了字节码之后，就能解决内存占用问题呢？

**ignition 的解释执行，是说把这句字节码解释成机器码然后执行（执行完毕后该段机器码被释放）再把下一句字节码解释成机器码然后执行。**

而原先v8的做法直接转化成一堆机器码，然后执行。

个人观点:
        应该是, 字节码不是一股脑的都生产机器码, 就按照老师说的那样子, 是逐条解释成机器码. 用完的机器码, 可以先进行释放, 从而减少了峰值内存. 不知道对不对.
        
 对，我也是这样想，一次性将所有字节码编译成机器码再执行，你肯定要保存起来对吧？那占用的内存就会比较大，所以一行一行编译再执行，执行完的可以清除了（热点代码除外）

