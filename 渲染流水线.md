#### 渲染流水线

由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线。可分为如下几个子阶段：

1. 构建 DOM 树

2. 样式计算

3. 布局阶段
4. 分层
5. 绘制
6. 分块
7. 光栅化和合成

#### DOM树的构建

![wIlrPx.png](https://s1.ax1x.com/2020/09/19/wIlrPx.png)

从图中可以看出，构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。



和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。

```javascript
document.getElementsByTagName("p")[0].innerText = "black"
```

---

#### 样式计算（Recalculate Style）

样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。

#### 1.把 CSS 转换为浏览器能够理解的结构

当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本（通过 link 引用的外部 CSS 文件）转换为浏览器可以理解的结构——styleSheets。

#### 2. 转换样式表中的属性值，使其标准化

要理解什么是属性值标准化，你可以看下面这样一段 CSS 文本：

```css
body { font-size: 2em }
p {color:blue;}
span  {display: none}
div {font-weight: bold}
div  p {color:green;}
div {color:red; }
```

可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。那标准化后的属性值是什么样子的？

![wItw60.png](https://s1.ax1x.com/2020/09/19/wItw60.png)

从图中可以看到，2em 被解析成了 32px，red 被解析成了 rgb(255,0,0)，bold 被解析成了 700……

#### 3.计算出 DOM 树中每个节点的具体样式

* 继承规则

![wIaO39.png](https://s1.ax1x.com/2020/09/19/wIaO39.png)

从图中可以看出，所有子节点都继承了父节点样式。比如 body 节点的 font-size 属性是 20，那 body 节点下面的所有节点的 font-size 都等于 20。



在`chrome`的控制台中表现如下

 ![wIdJuq.png](https://s1.ax1x.com/2020/09/19/wIdJuq.png)

* 层叠规则

总之，样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。

如果你想了解每个 DOM 元素最终的计算样式，可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，然后再选择“**Computed**”子标签，如下图所示：

![wIdaUU.png](https://s1.ax1x.com/2020/09/19/wIdaUU.png)

---

#### 布局阶段

计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。

1. 创建布局树

   DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。

   > 可以发现，布局树的构建是建立在 DOM 树（节点，文本信息）和 computedStyle（css信息） 的基础上 

   ![0aupdA.png](https://s1.ax1x.com/2020/10/07/0aupdA.png)

   2. 布局计算

   计算布局树节点的坐标位置

​		在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是		输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内		容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，		试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。

---

#### 分层

浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。因此我们需要一棵图层树，来描述页面中图层间的组织关系。

![0audF1.png](https://s1.ax1x.com/2020/10/07/0audF1.png)

通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。

* 怎样的元素会被提升为单独的一个图层呢？

  1. 拥有层叠上下文属性的元素会被提升为单独的一层

     ![0auo6S.png](https://s1.ax1x.com/2020/10/07/0auo6S.png)

     > 明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素

  2. 需要剪裁（clip）的地方也会被创建为图层。

     不过首先你需要了解什么是剪裁，结合下面的 HTML 代码：

     ```html
     <style>
           div {
                 width: 200;
                 height: 200;
                 overflow:auto;
                 background: gray;
             } 
     </style>
     <body>
         <div >
             <p>所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：</p>
             <p>从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。</p>
             <p>图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。</p> 
         </div>
     </body>
     ```

     在这里我们把 div 的大小限定为 200 * 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200 * 200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域，下图是运行时的执行结果：

     ![0aKAt1.png](https://s1.ax1x.com/2020/10/07/0aKAt1.png)出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。你可以参考下图

![0aKZp6.png](https://s1.ax1x.com/2020/10/07/0aKZp6.png)

---

#### 绘制（paint）

一个图层的绘制可以拆分成很多小的绘制指令。具体来说，一个图层由若干个元素组成，而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。

在图层绘制阶段，输出的内容就是这些待绘制列表。`也就是说，绘制阶段其实没有真正的 paint。`

---

#### 分块（tile）

* 视口

通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做**视口**（viewport）。

在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512。

---

#### 栅格化（raster）

栅格化负责将之前得到的图块转化为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。



通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫**快速栅格化**，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

---

#### 合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。



浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

---

下面对整个渲染流水线进行总结：



整个渲染流水线共涉及3个进程（渲染进程，GPU进程，浏览器进程），两个线程（渲染进程的主线程，渲染进程的合成线程），其中：

####  渲染进程的主线程做了什么

1. 构建DOM树
2.  computeStyle
3. 生成布局树
4. 构建图层树
5. 分层确定绘制指令



#### 渲染进程的合成线程做了什么

1.接受某个图层对应的绘制列表，将其划分为图块，
2.提交图块（视口附近的图块来优先生成位图）给栅格化线程池。
3.一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

#### GPU进程做了什么

生成图块的位图，并保存在 GPU 的内存中。




#### 浏览器进程做了什么

在接受到DrawQuad命令后，从GPU内存中读取位图，显示在屏幕上。

![0atK2j.png](https://s1.ax1x.com/2020/10/07/0atK2j.png)
